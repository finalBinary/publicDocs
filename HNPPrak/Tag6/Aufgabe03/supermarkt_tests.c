/*
 * DO NOT EDIT THIS FILE. Generated by checkmk.
 * Edit the original source file "Dateien/tag6/supermarkt/loesung/supermarkt_tests.ts" instead.
 */

#include <check.h>

#line 1 "Dateien/tag6/supermarkt/loesung/supermarkt_tests.ts"
#include "supermarkt.h"

/*

checkmk supermarkt_tests.ts > supermarkt_tests.c
gcc supermarkt.c supermarkt_tests.c -o tests -Wall -lcheck -lm -lpthread -lrt -std=c99 -g
./tests

*/

/*

int ausgeben(int haltbarkeit_allgemein, int haltbarkeit_obst, int mindestanzahl, int umkehren,
             int anzahl, char *kategorie, int resthaltbarkeit){
*/


// Teste ist_oft_genug_vorhanden

START_TEST(test_oft_genug_vorhanden)
{
#line 21
    ck_assert_int_eq(ist_oft_genug_vorhanden(5, 5), 1);
    ck_assert_int_eq(ist_oft_genug_vorhanden(5, 10), 1);
    ck_assert_int_eq(ist_oft_genug_vorhanden(10, 5), 0);



// Teste individuelle_haltbarkeit

}
END_TEST

START_TEST(test_individuelle_haltbarkeit_allgemein)
{
#line 30
    ck_assert_int_eq(individuelle_haltbarkeit(10, 20, "Gemüse"), 10);

}
END_TEST

START_TEST(test_individuelle_haltbarkeit_obst)
{
#line 33
    ck_assert_int_eq(individuelle_haltbarkeit(10, 20, "Obst"), 20);


// Teste ausgeben

//int ausgeben(int haltbarkeit_allgemein, int haltbarkeit_obst, int mindestanzahl, int umkehren, int anzahl, char *kategorie, int resthaltbarkeit);

}
END_TEST

START_TEST(ausgeben_standardfall)
{
#line 41
    ck_assert_int_eq(ausgeben(15, 15, 0, 0, 0, "Gemüse", 20), 1); 
    ck_assert_int_eq(ausgeben(15, 15, 0, 0, 0, "Gemüse", 10), 0); // nicht lang genug haltbar
    ck_assert_int_eq(ausgeben(15, 15, 0, 0, 0, "Gemüse", 15), 1); // Gleichheit ist auch ok
    ck_assert_int_eq(ausgeben(15, 15, 0, 0, 0, "Obst", 10), 0);   // nicht lang genug haltbar
    ck_assert_int_eq(ausgeben(15, 15, 0, 0, 0, "Obst", 20), 1);


}
END_TEST

START_TEST(ausgeben_obst_spezial)
{
#line 49
    ck_assert_int_eq(ausgeben(15, 5, 0, 0, 0, "Gemüse", 20), 1);
    ck_assert_int_eq(ausgeben(15, 5, 0, 0, 0, "Gemüse", 10), 0);  // nicht lang genug Haltbar 
    ck_assert_int_eq(ausgeben(15, 5, 0, 0, 0, "Obst", 10), 1);    
    ck_assert_int_eq(ausgeben(15, 5, 0, 0, 0, "Obst", 20), 1);    // Bei Obst ok
    ck_assert_int_eq(ausgeben(15, 5, 0, 0, 0, "Obst", 5), 1);     // Bei Obst ok
    ck_assert_int_eq(ausgeben(15, 5, 0, 0, 0, "Obst", 4), 0);     // Obst nicht lang genug Haltbar


}
END_TEST

START_TEST(ausgeben_mit_anzahl_obst_standard)
{
#line 58
    ck_assert_int_eq(ausgeben(15, 15,  5, 0, 5, "Gemüse", 20), 1); // genügend und haltbar
    ck_assert_int_eq(ausgeben(15, 15, 10, 0, 0, "Gemüse", 20), 0); // zu wenige und haltbar
    ck_assert_int_eq(ausgeben(15, 15, 10, 0, 0, "Obst", 0), 0);    // zu wenig und nicht haltbar
    ck_assert_int_eq(ausgeben(15, 15,  5, 0, 5, "Obst", 0), 0);    // genügend aber nicht haltbar


}
END_TEST

START_TEST(ausgeben_mit_anzahl_obst_spezial)
{
#line 65
    ck_assert_int_eq(ausgeben(15, 5, 10, 0, 10, "Gemüse", 20), 1); // genügend und haltbar
    ck_assert_int_eq(ausgeben(15, 5, 10, 0,  0, "Gemüse", 20), 0); // zu wenige und haltbar
    ck_assert_int_eq(ausgeben(15, 5, 10, 0,  0, "Gemüse", 0), 0);  // zu wenig und nicht haltbar
    ck_assert_int_eq(ausgeben(15, 5, 10, 0, 10, "Gemüse", 0), 0);  // genügend aber nicht haltbar
    
    ck_assert_int_eq(ausgeben(15, 5, 10, 0, 10, "Obst", 10), 1);   // genügend und haltbar
    ck_assert_int_eq(ausgeben(15, 5, 10, 0,  0, "Obst", 10), 0);   // zu wenige und haltbar
    ck_assert_int_eq(ausgeben(15, 5, 10, 0,  0, "Obst", 0), 0);    // zu wenig und nicht haltbar
    ck_assert_int_eq(ausgeben(15, 5, 10, 0, 10, "Obst", 0), 0);    // genügend aber nicht haltbar

}
END_TEST

START_TEST(ausgeben_mit_umkehren)
{
#line 76
    ck_assert_int_eq(ausgeben(15, 15,  5, 1, 5, "Gemüse", 15), 1); // genügend und haltbar
    ck_assert_int_eq(ausgeben(15, 15, 10, 1, 0, "Gemüse", 0), 0);  // zu wenige und haltbar
    ck_assert_int_eq(ausgeben(15, 15, 10, 1, 0, "Obst", 15), 0);   // zu wenig und nicht haltbar
    ck_assert_int_eq(ausgeben(15, 15,  5, 1, 5, "Obst", 20), 0);   // genügend aber nicht haltbar
    
    ck_assert_int_eq(ausgeben(15, 5, 10, 1, 10, "Gemüse", 15), 1); // genügend und haltbar
    ck_assert_int_eq(ausgeben(15, 5, 10, 1,  0, "Gemüse", 0), 0);  // zu wenige und haltbar
    ck_assert_int_eq(ausgeben(15, 5, 10, 1,  0, "Gemüse", 15), 0); // zu wenig und nicht haltbar
    ck_assert_int_eq(ausgeben(15, 5, 10, 1, 10, "Gemüse", 20), 0); // genügend aber nicht haltbar
    
    ck_assert_int_eq(ausgeben(15, 5, 10, 1, 10, "Obst", 5), 1);   // genügend und haltbar
    ck_assert_int_eq(ausgeben(15, 5, 10, 1,  0, "Obst", 0), 0);   // zu wenige und haltbar
    ck_assert_int_eq(ausgeben(15, 5, 10, 1,  0, "Obst", 5), 0);   // zu wenig und nicht haltbar
    ck_assert_int_eq(ausgeben(15, 5, 10, 1, 10, "Obst", 10), 0);  // genügend aber nicht haltbar
}
END_TEST

int main(void)
{
    Suite *s1 = suite_create("Core");
    TCase *tc1_1 = tcase_create("Core");
    SRunner *sr = srunner_create(s1);
    int nf;

    suite_add_tcase(s1, tc1_1);
    tcase_add_test(tc1_1, test_oft_genug_vorhanden);
    tcase_add_test(tc1_1, test_individuelle_haltbarkeit_allgemein);
    tcase_add_test(tc1_1, test_individuelle_haltbarkeit_obst);
    tcase_add_test(tc1_1, ausgeben_standardfall);
    tcase_add_test(tc1_1, ausgeben_obst_spezial);
    tcase_add_test(tc1_1, ausgeben_mit_anzahl_obst_standard);
    tcase_add_test(tc1_1, ausgeben_mit_anzahl_obst_spezial);
    tcase_add_test(tc1_1, ausgeben_mit_umkehren);

    srunner_run_all(sr, CK_ENV);
    nf = srunner_ntests_failed(sr);
    srunner_free(sr);

    return nf == 0 ? 0 : 1;
}
